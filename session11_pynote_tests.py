# -*- coding: utf-8 -*-
"""session10_pynote_tests.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bhzaSyKgJaq8u-wmfCmrjegTTCaoEmTi

## Polygon Class definition
"""

from functools import wraps
import math
from functools import lru_cache

# Timed decorator for all functions - but using a global variable for elapsed time in case we want it at __main__ level
elapsed_time = 0

def timed(fn: 'Function name') -> 'Time for execution of the function':
    """
    A function decorator to compute the execution time for all the functions in this module when called
    from the test script.
    Params:
    fn - Function name
    Returns:
        Time for execution in seconds
    """
    from time import perf_counter
    @wraps(fn)
    def inner(*args, **kwargs):
        global elapsed_time
        start_time = perf_counter()
        result = fn(*args, **kwargs)
        end_time = perf_counter()
        elapsed_time = end_time - start_time
        print(f"Function {fn.__name__}() took {elapsed_time} secs to execute")
        return result

    return inner


# Function decorator for checking the docstring of functions
def check_doc_string(
        fn: 'Function name that needs to be parsed') -> 'Returns True if the function has 50 words of description':
    """
    This function checks whether the function passed on to this has atleast 50 words of
    description.
    :param fn: Function name that is passed to this function
    :return: Returns a closure which allows the free variables can be accessed later
             The inner function Returns True if it has 50 or more words in its docstring description, else False
    Question: Will the docstring include the argument description function as well?  A BIG NO!
    """
    comment_len = 50
    """
    Doc string for inner function
    :param args: Positional arguments for the function
    :param kwargs:Function arguments for the function
    :return: The function output
    """
    if fn.__doc__ is None:
        return False
    else:
        fn_doc_string = fn.__doc__.split(sep=" ")
        # print(f'No. of words in the docstring comment for {fn.__name__}() is : {len(fn_doc_string)}')
        if len(fn_doc_string) < comment_len:
            return False
        else:
            return True


class Polygon:
    """
    Class definition for a n-Polygon: creating a regular polygon of equal sides with n sides
    """

    @timed
    def __init__(self, s: 'No. of sides (int)' = 3, r: 'Circum radius' = 1):
        """
        Init for polygon class
        Args:
            s: No. of edges or vertices (integer) - default 3
            r: Circum radius, i.e., distance between the center and one of the vertices - default 1
        Returns: None - Initializes the object
            The class object with the following parameters initialized
                int_angle = (s-2) * 180.0/s  --> Interior angle
                edge_len = 2 * r * math.sin(math.pi/s)  --> length of one edge
                apothem = r * math.cos(math.pi/s)   --> distance between the center and line joining two vertices
                area = 0.5 * s * self.edge_len * self.apothem  --> area of the polygon
                perimeter = s * edge_len  --> Perimeter
                vertices = No. of vertices = no. of edges --> No of vertices
        """
        if s < 3:
            raise TypeError("No. of edges cannot be less than 3")

        self.edges = s
        self.radius = r
        self.int_angle = (s - 2) * 180.0 / s
        self.edge_len = 2 * r * math.sin(math.pi / s)
        self.apothem = r * math.cos(math.pi / s)
        self.area = 0.5 * s * self.edge_len * self.apothem
        self.perimeter = s * self.edge_len
        self.vertices = s

    def __repr__(self):
        print(f'Regular polygon with {self.edges} sides and circum radius = {self.radius}')
        print(f'The class object with the following parameters initialized')
        print(f'edges     --> No. of edges = {self.edges}')
        print(f'radius    --> circum radius = {self.radius}')
        print(f'int_angle --> Interior angle = {self.int_angle}')
        print(f'edge_len  --> length of one edge = {self.edge_len}')
        print(f'apothem   --> distance between the center and line joining two vertices is = {self.apothem}')
        print(f'area      --> area of the polygon = {self.area}')
        print(f'perimeter --> perimeter  = {self.perimeter}')
        print(f'vertices  --> No of vertices = {self.vertices}')

    def __eq__(self, other):
        """
        Checks whether two polygons are equal or not. The first polygon is self
        Args:
            other: The second polygon
        Returns:
            True if no. of sides and radius are equal else False
        """
        return True if (self.edges == other.edges and self.radius == other.radius) else False

    def __gt__(self, other):
        """
        Checks whether one of two polygons is greater than the other. The first polygon is self
        Args:
            other: The second polygon
        Returns:
            True if no. of sides of first is more than the second's
        """
        return True if (self.edges > other.edges) else False

"""## Polygon Sequence Class Definition"""

class PolygonSeq(Polygon):
    """
    Polygon sequence class derived from the polygon class object
    """

    def __init__(self, n, r):
        """
        Creates a polygon sequence with the largest polygon with n sides and r radius
        Also computes the maximum efficiency polygon which has the highest area to perimeter ratio
        Args:
            n: Maximum no. of edges or sides
            r: Circum radius of all polygons
        """
        self.n = n  # Maximum no. of polygon available in the sequence
        self.r = r
        self.max_eff_n = 3
        self.max_eff = 0
        self.curr_poly = n  # default polygon index

        max_eff = 0
        for i in range(3, n + 1):
            temp_poly = self._polygon(i, r)
            eff = temp_poly.area / temp_poly.perimeter
            if self.max_eff < eff:
                self.max_eff = eff
                self.max_eff_n = i

    @staticmethod
    @lru_cache(maxsize=100)
    def _polygon(s, r):
        """
        Computes the polygon of given order and radius
        Args:
            s: Polygon order
            r: Circum radius of the polygon
        Returns:
            The polygon class object
        """
        return Polygon(s, r)

    def __repr__(self):
        """
        Gives the description of the PolygonSeq class objects.
        Returns:
            Print statement of the length (maximum order), radius and the maximum efficiency polygon
        """
        print(f'Polygon sequence of length = {self.n} with radius = {self.r}')
        print(f'The maximum efficiency polygon is with edges = {self.max_eff_n}')
        print(f'The maximum efficiency (area/perimeter) is {self.max_eff}')

    def __len__(self):
        """
        Returns the length of the polygon sequence. The length refers to the maximum order in the sequence
        Returns:
            The highest polygon order
        """
        return self.n

    def __getitem__(self, s):
        """
        Gets the polygon of order s
        Args:
            s: The order of the polygon
        Returns:
            The polygon of order s
        """
        if isinstance(s, int):
            if s < 3 or s > self.n:
                raise IndexError
            else:
                return self._polygon(s, self.r)

    def _next(self):
        """
        Return the next polygon in the sequence.
        The polygon class object which is next in the sequence is returned.
        The current sequence number is updated.
        """
        if self.curr_poly < self.n:
            self.curr_poly += 1
            return self.__getitem__(self.curr_poly)
        else:
            print("Reached the end of sequence")
            return self.__getitem__(self.n)
            # raise IndexError

    def _prev(self):
        """
        Return the previous polygon in the sequence
        The polygon class object which is previous in the sequence is returned.
        The current sequence number is updated.
        """
        if self.curr_poly >= 4:
            self.curr_poly -= 1
            return self.__getitem__(self.curr_poly)
        else:
            print("Reached start of sequence")
            return self.__getitem__(3)
            # raise IndexError

"""## Test cases for Polygon class objects"""

#gon2 = Polygon(2, 1)    # Raise TypeError due to invalid polygon order
gon3 = Polygon(3, 1)
gon3.__repr__()
gon6 = Polygon(6, 2)
print(gon3 == gon6)
print(gon6 > gon3)

"""## Test cases for Polygon Sequence object"""

gon_seq = PolygonSeq(5, 1)
gon_seq.__repr__()
print(gon_seq.__len__())
print('*** Pentagon properties')
gon_seq[5].__repr__()
print('*** Square properties')
gon_seq._prev().__repr__()
print('*** Triangle properties')
gon_seq._prev().__repr__()
print('*** Square properties')
gon_seq._next().__repr__()
print(f'Maximum efficiency polygon is {gon_seq.max_eff_n} with efficiency {gon_seq.max_eff}')